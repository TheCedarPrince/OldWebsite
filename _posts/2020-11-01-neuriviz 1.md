---
title: "NeuriViz (Part 1) - Performant Graphics for Neuroinformatics"
image:
  path: /assets/brain_tiles.png
comments: true
share: true
---

I am quite excited to introduce a new side-project of mine called [`NeuriViz`](https://github.com/TheCedarPrince/NeuriViz)!
`NeuriViz` is a proof of concept application of the [`Javis.jl`](https://github.com/Wikunia/Javis.jl) package to create performant animated graphics and visualizations for the domain of neuroinformatics! 

# How Did `NeuriViz` Come to Be?

[`NeuriViz`](https://github.com/TheCedarPrince/NeuriViz) started as an offshoot of my work on [`Javis.jl`](https://github.com/Wikunia/Javis.jl) that my friend, [Ole Kröger](https://opensourc.es/about/), and I created.
The `Javis` package acts as a general purpose library to easily construct informative, performant, and winsome animated graphics using the [Julia programming language](https://julialang.org/).
While working on `Javis`, I realized it had potential to be applied to domain specific graphics that can be difficult to make.
Given [my background in health sciences and cognitive disabilities](/about/), I used `Javis` to create an animation of a 10-20 EEG Electrode Array:

![](/assets/simple_10_20_array.gif)
{: style="text-align: center;"}

After I had created this, I reached out to a neuroscientist that I knew.
From there, I was connected with my collaborator on the project, Zachary Christensen, the creator of the [JuliaNeuroscience](https://github.com/JuliaNeuroscience) organization.
Finally, after a few different conversations, `NeuriViz` was created.

# Creating EEG Topoplots with Julia

Obviously, the 10-20 EEG electrode array animation is not particularly useful to a neuroinformaticist. 
However, what it was useful for was to illustrate an important aspect of NeuriViz: every single component of that animation was original.
I created the "template" for this array by using `Luxor` objects which `Javis` exports and was able to, after defining constants and package imports, [draw the EEG within 40 lines of code](https://wikunia.github.io/Javis.jl/stable/tutorials/tutorial_2/#Full-Code).

The first animation goal of NeuriViz is to produce a performant EEG topoplot.
The following image is taken from documentation of the popular MATLAB EEG toolbox, [EEGLAB](https://sccn.ucsd.edu/eeglab/index.php), to illustrate exactly what is envisioned:

![](/assets/eeglab_topoplot.jpg)
{: style="text-align: center;"}

Currently, with help from the creator of `Luxor`, Cormullion, I have been able to produce the following topoplot example using signal noise and my template:

![](/assets/proto_eeg_topo.jpg)
{: style="text-align: center;"}

The data here is nonsensical but creating this entire prototype of a 10-20 EEG electrode array only took about [20 lines more than my original example](https://gist.github.com/TheCedarPrince/592ec8112302af4230ccc27614303a6f).

There is still much to do with making a fully functioning topoplot using `Javis`.
For starters, the poor subject is missing a nose and ears!
As shown in the example from EEGLAB, there are no boundaries between different activity gradients. 
Finally, taking actual channel data and interpolating it across the contour of the skull to create the actual topoplot is a non-trivial process.

However, I am confident that not only is this surmountable but that we can make animations for brain activity across epochs in a fast and performant way.
Why do I think that? 
Let's get to that in the next section where we talk about data pipelines!

# NeuriViz Data-to-Visualization Pipelines

```julia
transpose(data) |> DataFrame
```

Tremendous thank you to @Zachary Christensen for creating AxisIndices.jl and @quinnj for spearheading development on Arrow.jl (as well as answering some random questions that I have pertaining to Apache Arrow). I have spent the last week working on a ~10GB EEG dataset from openneuro.org (Go-nogo Categorization and Detection Task Dataset). Originally, this dataset was made specifically for the MATLAB tool, EEGLAB, but I was able to parse it to Julia readable input and convert the relevant data to .arrow binary files. From there, I did some very light benchmarking on reading and writing of Arrow files in conjunction with DataFrames.jl:
julia> using Arrow, BenchmarkTools, DataFrames, NeuriViz
julia> fdt_readable = fdt_parser(fdt_path, dims) |> permutedims |> DataFrame;
julia> println("$(size(fdt_readable)[1] * size(fdt_readable)[2]) values in this DataFrame.")
6399640 values in this DataFrame.
julia> @btime Arrow.write("eeg_data.arrow", fdt_readable);
  15.527 ms (1140 allocations: 104.30 KiB)
julia> @btime Arrow.Table("eeg_data.arrow") |> DataFrame;
  82.728 μs (1820 allocations: 106.42 KiB)
I thought this was immensely impressive and suitable for my use case of dealing with nearly ~2 billion data values. Further, the minimal allocations is quite nice and doesn't blow up my computer (I am sure some of my code here and methods could be improved, but I am already very pleased). After research and discussion, I think the implementation of Arrow.jl is very clean in that it natively handles memory mapping and allows me to work with "larger than memory" datasets.
After I got my data into .arrow formats came the complicated bit of finding a proper data structure to handle the information I had. The data was split across five different file formats and to find something that would allow me to handle time series data, tables, and miscellaneous information was complicated. Following much experimentation with tools such as AxisArrays.jl, NamedArrays.jl, and RecursiveArrayTools.jl, I tested AxisIndices and it was perfect for my use case (the other packages are great by the way - I am not sure if I explored them properly enough but I could not make them meet my need). When I constructed a data structure based off of AxisIndices.jl, I decided to do some light benchmarking as well on loading all my eeg data into an AxisArray:
julia> @btime load_eeg_data();
  142.191 μs (2444 allocations: 149.77 KiB)
Finally, the data structure that I was able to produce is so beautiful and simple to use. Dare I say, the accessing of the data structure may even be self-explaining as code. Please see the attached photo so you can see what I mean! Apologies for the long post but I was shocked at how amazing this entire process was. Kudos for the great and important work (also thanks for @turingtest37, @Oscar Smith, @chrisrackauckas , and @christopher-dG for additional help with me trying to figure this all out).
