---
title: "NeuriViz (Part 2) - EEG Topoplots"
image:
  path: /assets/neuriviz_p2_hero_img.png
comments: true
share: true
tags:
    - julia
    - neuroscience
    - visualization
---

In [Part 1 of NeuriViz](/neuriviz-1/) project updates, I laid out the purpose and general approach I am taking to creating neuroscientific visualizations.
The first visualization I had the goal of creating was an EEG topoplot inspired by such projects like [EEGLAB](https://sccn.ucsd.edu/eeglab/index.php) and [MNE](https://mne.tools/stable/index.html).
I am happy to say that, after writing this in pure Julia, that this goal has now been achieved!

![](/assets/topoplot_v1_proto.png)
{: style="text-align: center;"}

The following sections takes you through how I accomplished this!

If you find this blog post useful, please consider citing it:

> Jacob Zelko. _NeuriViz (Part 2) - EEG Topoplots_. December 15th, 2020. http://jacobzelko.com

# Preparing BIDS EEG Data from OpenNEURO [DONE]

As I talked about in [my previous post](http://jacobzelko.com/neuriviz-1/#neuriviz-data-to-visualization-pipelines), I am using data from [OpenNEURO](https://openneuro.org/) which is a "A free and open platform for sharing MRI, MEG, EEG, EEG, and ECG data". [1]
The data follows the [Brain Imaging Data Structure (BIDS)](https://bids.neuroimaging.io/) so the first order of business was parsing this data. [2] 
Furthermore, I am using the [_Go-nogo categorization and detection task_](https://openneuro.org/datasets/ds002680/versions/1.0.0) dataset by Delorme et. al. [3] which was made in conjunction with the tool, [EEGLAB](https://sccn.ucsd.edu/eeglab/index.php). [4]
As a result, the data is not readily accessible to Julia.

Sadness abounds! :sob:

However, thankfully, we can convert the data into formats that Julia can easily read and work with!
From the dataset, there were only three files for each subjects' session that I used to create the topoplot; here they are ranked in order of importance:

1. `.fdt` files which stores the raw EEG recordings' "float data" in a binary format. [1]
2. `.set` files, which are actually MATLAB `mat` files, go alongside `.fdt` files to store Metadata related to that session (e.g. channels being used, sampling frequency, etc.). [2]
3. `.tsv` files which show how many electrodes were used and where they were attached on the skull.

For my use case, I decided to convert these files to the [Apache Arrow](https://arrow.apache.org/) file format as specified by [`feather`](https://ursalabs.org/blog/2020-feather-v2/).
The rationale is that Julia has strong support for Arrow thanks to the [JuliaData organization](https://github.com/JuliaData) and [`Arrow.jl`](https://github.com/JuliaData/Arrow.jl) which is supported by Julia Developer, [Jacob Quinn](https://quinnj.home.blog/), strong interoperability with [`DataFrames.jl`](https://github.com/JuliaData/DataFrames.jl) thanks to [Bogumił Kamiński](http://bogumilkaminski.pl/about/) so we can work easily with dataframe structures, and [is incredibly fast](http://jacobzelko.com/neuriviz-1/#neuriviz-data-to-visualization-pipelines) to work with. 
I will spare most of the details on how this was done, but if you are curious, NeuriViz provides a script called `load_dataset.jl` which handles this conversion for you.
Feel free to check that out in `neuriviz/scripts/load_dataset.jl`.

Once the data has been processed, we are good to go on with creating the topoplot!

> **NOTE: How is NeuriViz structured?**
>
> You may notice if you visit the [NeuriViz Repo](https://github.com/TheCedarPrince/NeuriViz), it seems to follow a specific structure.
> This structure is provided by the great project, [`DrWatson.jl`](https://github.com/JuliaDynamics/DrWatson.jl) created by theoretical physicist [George Datseris](https://datseris.github.io/).
It's goal is to create easily reproducible Julia code bases around scientific exploration.
> The `DrWatson.jl` directory structure is as follows, and is what NeuriViz uses:
``````
│projectdir          <- Project's main folder. It is initialized as a Git
│                       repository with a reasonable .gitignore file.
│
├── _research        <- WIP scripts, code, notes, comments,
│   |                   to-dos and anything in an alpha state.
│   └── tmp          <- Temporary data folder.
│
├── data             <- **Immutable and add-only!**
│   ├── sims         <- Data resulting directly from simulations.
│   ├── exp_pro      <- Data from processing experiments.
│   └── exp_raw      <- Raw experimental data.
│
├── plots            <- Self-explanatory.
├── notebooks        <- Jupyter, Weave or any other mixed media notebooks.
│
├── papers           <- Scientific papers resulting from the project.
│
├── scripts          <- Various scripts, e.g. simulations, plotting, analysis,
│   │                   The scripts use the `src` folder for their base code.
│   └── intro.jl     <- Simple file that uses DrWatson and uses its greeting.
│
├── src              <- Source code for use in this project. Contains functions,
│                       structures and modules that are used throughout
│                       the project and in multiple scripts.
│
├── README.md        <- Optional top-level README for anyone using this project.
├── .gitignore       <- by default ignores _research, data, plots, videos,
│                       notebooks and latex-compilation related files.
│
├── Manifest.toml    <- Contains full list of exact package versions used currently.
└── Project.toml     <- Main project file, allows activation and installation.
                        Includes DrWatson by default.
``````

# Mapping EEG Electrode Locations [DONE]

_Delorme et. al._ reports in their paper on the _Go-nogo_ dataset that after processing, their topoplot, with the associated EEG electrode array, looks like this:

![](/assets/delorme_topoplot.png)
{: style="text-align: center;"}

To reproduce the EEG channel array, NeuriViz provides a function called `load_eeg_data` which takes as input three paths: 

- EEG data that you want to load
- Electrode information associated with that EEG data
- Event data from that recording session

This returns a nested `NamedAxisArray` which contains our subject data for that session (learn more about `NamedAxisArray`'s from the [`AxisIndices.jl`](https://github.com/Tokazama/AxisIndices.jl) project by my collaborator Zachary Christensen).
NeuriViz provides an `Electrode` object which defines a `label`, `position` on the head, and `data` recorded from that channel for the particular session loaded by `load_eeg_data`.
To use this data to create an EEG array as shown by _Delorme et. al._, we utilize this `Electrode` object and create an array of `Electrode` objects for our session and subject.
We do this by utilizing this code snippet:

```julia 
subject_data = load_eeg_data(eeg_data_path, electrodes_data_path, event_data_path);

electrode_array = [
    Electrode(
        subject_data[subject = 1][session = 1][information = :electrodes][row, :].name,
        [
            subject_data[subject = 1][session = 1][information = :electrodes][row, :].x,
            subject_data[subject = 1][session = 1][information = :electrodes][row, :].y,
            subject_data[subject = 1][session = 1][information = :electrodes][row, :].z,
        ],
        @view subject_data[subject = 1][session = 1][information = :data][row]
    )
    for
    row = 1:size(subject_data[subject = 1][session = 1][information = :electrodes])[1]
];
```

This loads in EEG data into the `subject_data` variable via the `load_eeg_data` function and then creates an array of electrodes, `electrode_array`, using the `Electrode` object.

> **NOTE: What is `@view`?**
>
> From the Julia docs, `@view`, "creates a `SubArray` from an indexing expression."
> What this means, is rather than creating a copy of an array we're indexing, it returns a reference, or a "view", of the values shown without any additional allocation cost.

We then pass `electrode_array` into the NeuriViz provided `eeg_array` function to finally draw the electrode channels on our head.
We use this code snippet here to do that:

```julia
demo = Video(500, 500)

eeg_array(
    demo,
    electrode_array,
    electrode_array[27],
    subject_data[subject = 1][session = 1][information = :nosedir],
    50,
    true
)
```

This produces the following layout:

![](/assets/prototype_javis_render.jpg)
{: style="text-align: center;"}

> **NOTE: Why are channel locations not the same on a NeuriViz topoplot?**
>
> As an aside, if you notice, the electrodes in the Delorme topoplot are actually set inside the head of their topoplot more than mine.
I investigated why this is and while exploring EEGLAB (version 9.4.0.813654 (R2018a)), I found [`topoplot.m`](https://github.com/sccn/eeglab/blob/develop/functions/sigprocfunc/topoplot.m).
It is quite possible the kwarg of that function, `headrad`, was used to pretty the plot as it can mess with the anatomical proportions.
The paper did state that "arbitrary units" were used in the construction of that graphic.
Furthermore, it was not clear what project they used to display the channels.
Since they did not provide their code, I think it reasonable that these dilemmas account for the differences.

# Constructing a Channel Grid

Now that we have access to the session `subject_data` and the corresponding `electrode_array`, we can now begin the work of previewing the raw EEG data using `Plots.jl`.
We have one serious problem however: we have 31 channels but, based on our `Video` object defined in the previous section, `demo`, we have a matrix with the dimensions $$500 \times 500$$ to fill.
How do we address this situation?
One word: interpolations!

Thankfully, NeuriViz provides the function, `topoplot_heatmap` which handles this for us.
We accomplish this by using the following code snippet:

```julia
hmap = topoplot_heatmap(
    demo,
    Multiquadric(),
    electrode_array,
    subject_data[subject = 1][session = 1][information = :nosedir],
)

heatmap(hmap, aspect_ratio=:equal, c=:gist_yarg, axis=false, title="EEG Heatmap")
```

> **NOTE: What is `Multiquadric()` and Why Is It Used?**
>
>

![](/assets/heatmap_prototype_2.png)
{: style="text-align: center;"}

# Creating an EEG Heatmap

# Combining Everything to a Topoplot

Now that I have gone over how NeuriViz performs each individual step, we can now combine these steps to create an EEG Topoplot! :smile:
Here is an image showing that process:

![](/assets/neuriviz_topoplot_creation.png)
{: style="text-align: center;"}

<!--TODO: ADD FIG NUMBER-->

_Fig XX:_
_EEG topoplot creation using NeuriViz._
_The steps to create the topoplot is to calculate where the electrodes on a skull are placed, interpolate the recorded values across the skull, and finally overlay the electrodes on the final interpolated values._

# NeuriViz Benchmarks and Next Steps [DONE]

Now, the question is: how performant is NeuriViz currently?
Currently, unoptimized, here are benchmarks for different video resolutions:

![](/assets/neuriviz_benchmarks_1.png)
{: style="text-align: center;"}

<!-- TODO: ADD FIG NUMBER -->

_Fig XX:_
_NeuriViz benchmarks for creating topoplots_
_Here, examined from left to right, are animated gifs created with the dimensions of 100 x 100, 200 x 200, and 300 x 300 pixels._
_Consistently, it takes roughly 5x's the amount of time to render frames as it does to actually perform the calculations related to creating the frames._

From Fig XX, one can see different resolutions at which animated gifs were created using NeuriViz.
In this case, we are generating a topoplot at the image dimensions of 100 x 100, 200 x 200, 300 x 300.
There are two benchmark values associated with each image:

- **Create Frames** - This time benchmark is for the calculations needed to create aspects of the visualization such as the heatmap, location of where electrodes are placed, what objects go where, etc. 

- **Render Frames** - This time benchmark is for the time it takes to actually draw all the objects calculated while creating frames onto a drawing and collate each frame together into a media format.

In short, to create frames is about 5x's faster than it is to render the frames.
This is to be expected as rendering frames is often a time intensive process.
In this case, we create 1865 frames from the Delorme dataset after we downsample the sampling rate from 1000 Hz to 4 Hz and render them.

However, what may be somewhat surprising is that it does take a while for creating frames and rendering frames.
The worst case scenario regarding time is the 300 x 300 animation which takes nearly 20 minutes to render everything.
Ouch!

Yet, there is good news here!
The current iteration of Javis is very unoptimized which means, there is plenty of room for improvement.
Some examples of the current lack of optimizations are as follows: 

- Right now, NeuriViz calculates a full 300 x 300 matrix of interpolated values as opposed to the areas where it is only needed (e.g. the disc of the topoplot).
- I did not attempt to parallelize anything in this prototype example - which is another performance hit.
- The biggest bottle neck in creating visualizations is rendering via `FFMPEG`.
There are specific optimizations one could perform but I have not investigated these further yet.

Addressing these issues would certainly improve performance though it is hard to say by how much at this stage.

# Conclusion


![](/assets/topoplot_v1_proto.png)
{: style="text-align: center;"}

